<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section>
					<h1>Testen mit Angular</h1>
				</section>

				<section>
					<section>
						<h2>Grundlagen</h2>
					</section>
					<section>
						<h3>Warum testen?</h3>
					</section>
					<section>
						<h3>Was testen?</h3>
					</section>
					<section>
						<h3>Testarten</h3>
						<ul>
							<li class="fragment" data-fragments-index="1"><b>Isolierte Unit tests</b>: Testen einzelner Klassen</li>
							<li class="fragment" data-fragments-index="2"><b>"Shallow" Unit tests</b>: Testen der View</li>
							<li class="fragment" data-fragments-index="3"><b>Integrationstests</b>: Testen die Interaktion von Klassen</li>
							<li class="fragment" data-fragments-index="4"><b>E2E-Tests</b>: Simulieren Benutzerinteraktionen</li>
						</ul>
					</section>
					<section>
						<h3>Tools</h3>
						<ul>
							<li class="fragment" data-fragments-index="1"><b>Test runner</b>: Automatisiert Tests (bspw. <b>Karma</b>)
								<li class="fragment" data-fragments-index="2"><b>Testframework</b>: Klassen / Methoden zum Erstellen von Tests. Bspw.
									<ul>
										<li><b>Jasmine</b>: Testframework primär für Unit- und Integration-Tests </li>
										<li><b>Protractor</b>: Testframework für E2E-Tests</li>
									</ul>
								</li>
								<li class="fragment" data-fragments-index="3">
									<b>Angular testing utilities</b>: Methoden für das spezifische Testen von Angular-Komponenten
								</li>
								<ul>
					</section>
					<section>
						<h3>Testen mit Angular CLI</h3>
						<ul>
							<li class="fragment" data-fragments-index="1"><code>ng new</code> installiert und konfiguriert Karma (<i>karma.conf.js</i>), Protractor (<i>protractor.conf.js</i>) und Jasmine</li>
							<li class="fragment" data-fragments-index="2"><code>ng g c</code> erstellt zusätzlich zu der eigentlichen Komponente eine Testdatei (<code>...spec.ts</code>). Gleiches gilt für <i>Services</i>, <i>Pipes</i>, <i>Directives</i> und <i>Guards</i></li>
							<li class="fragment" data-fragments-index="3"><code>ng test</code> für Tests mit Karma</li>
							<li class="fragment" data-fragments-index="4"><code>ng e2e</code> für E2E-Tests mit Protractor</li>
					</section>
				</section>
				<section>
					<section>
						<h2>Isolierte Unit Tests mit Jasmine</h2>
					</section>
					<section>
						<h3>Grundlagen Unit Testing</h3>
						<ul>
							<li class="fragment" data-fragments-index="1">Ein Unit Test ist eine Annahme über die Funktionsweise von Code</li>
							<li class="fragment" data-fragments-index="2">Wichtig: Auch "edge cases" für Inputs testen! Bspw.
								<ul>
									<li>für Zahlen: <code>undefined</code>, <code>0</code>, negative Zahlen, Maximal-/Minimalwerte</li>
									<li>für Strings: <code>undefined</code>, <code>''</code>, Steuer- / Sonderzeichen</li>
								</ul>
							</li>
							<li class="fragment" data-fragments-index="3">Tests sind kein Beweis für Fehlerfreiheit!</li>
							<li class="fragment" data-fragments-index="4">Tests werden in separater Datei geschrieben</li>
							<li class="fragment" data-fragments-index="5">Jasmine: BDD-Framework &#65515; Spezifikationen in "natürlicher" Sprache</li>
						</ul>
					</section>
					<section>
						<h3>Jasmine: Methoden (Auswahl)</h3>
						<ul>
							<li class="fragment" data-fragments-index="1"><code>describe</code>: Erstellt eine Gruppe von Spezifikationen</li>
							<li class="fragment" data-fragments-index="2"><code>it</code>: Ertellt eine Spezifikation</li>
							<li class="fragment" data-fragments-index="3"><code>expect</code>: Erstellt eine Erwartung für einen Test (wird durch <i>Matcher</i> spezifiziert)</li>
							<li class="fragment" data-fragments-index="4"><code>beforeEach</code> / <code>beforeAll</code>: Führt Funktion vor einer / allen Spezifikationen aus</li>
					</section>
					<section>
						<h3>Jasmine: Matchers</h3>
						<ul>
							<li class="fragment" data-fragments-index="1"><i>Matchers</i>: Vergleichen erwarteten mit tatsächlichem Wert eines Objektes</li>
							<li class="fragment" data-fragments-index="2">Muster: <code>expect(&lt;obj&gt;).{not.}matcher(&lt;testwert&gt;)</code></li>
							<li class="fragment" data-fragments-index="3">Matchers (Auswahl):
								<ul>
									<li class="fragment" data-fragments-index="4"><code>toBeDefined</code> / <code>toBeUndefined</code>: Objekt ist definiert / nicht definiert</li>
									<li class="fragment" data-fragments-index="5"><code>toBe</code>: Werte sind gleich (<code>===</code>)</li>
									<li class="fragment" data-fragments-index="6"><code>toContain</code>: Objekt enthält Wert</li>
									<li class="fragment" data-fragments-index="7"><code>toMatch</code>: Wert matcht mit regulärem Ausdruck</li>
									<li class="fragment" data-fragments-index="8"><code>toEqual</code>: Objektgleichheit</li>
									<li class="fragment" data-fragments-index="9"><code>toBeTruthy</code> / <code>toBeFalsy</code>: Objekt ist <code>true</code> / <code>false</code></li>
									<li class="fragment" data-fragments-index="10"><code>toThrow</code>: Wirft Fehler</li>
								</ul>
							</li>
							</ul>
					</section>
					<section>
						<h3>Beispiel</h3>
						<pre><code style="font-size:80%" data-trim data-noescape>class IsolatedUnitTests {
	static times2(n: number) {
		return n * 2;
	}
}

// Tests normalerweise in separater Datei!
describe('times2 in IsolatedUnitTests', () => { // OK!
	it ('should return 6 given 3', () => {
			expect(IsolatedUnitTests.times2(3)).toBe(6);
	});
	it ('should return 4 given -2', () => { // Schlägt fehl!
		expect(IsolatedUnitTests.times2(-2)).toBe(4);
	});
	it ('should return NaN value given an undefined value', () => { // OK!
		expect(IsolatedUnitTests.times2(undefined)).toBeNaN();
	});
});</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>"Shallow" Unit Tests mit Jasmine und Angular Testing Utilities</h2>
					</section>
					<section>
						<h3>"Isolierte" vs. "Shallow" Unit Tests</h3>
						<ul>
							<li>Isolierte Unit Tests für: Services, Pipes, Geschäftslogik in Komponenten</li>
							<li>"Shallow" Unit Tests für: DOM-Manipulationen in Komponenten und Templates</li>
						</ul>
					</section>
					<section>
						<h3>Angular Testing Utilities</h3>
						<ul>
							<li class="fragment" data-fragments-index="1">Sammlung von Klassen, die das Testen der View erleichtern</li>
							<li class="fragment" data-fragments-index="2">Umfasst:
								<ul>
									<li class="fragment" data-fragments-index="3"><a href="https://angular.io/api/core/testing/TestBed" target="api"><code>TestBed</code></a>: Konfigurierbares Test-Modul zum Ausführen der Komponente. Enthält <a href="https://angular.io/guide/testing#testbed-class-summary" target="api">Methoden</a> zur Manipulation des globalen Test-Moduls</li>
									<li class="fragment" data-fragments-index="4"><a href="https://angular.io/api/core/testing/ComponentFixture" target="api"><code>ComponentFixture</code></a>: Referenz auf Instanz der Komponente unter Test. Enthält <a href="https://angular.io/guide/testing#componentfixture-methods" target="api">Methoden</a> zum Auslösen von Aktionen im Komponenten-Baum</li>
									<li class="fragment" data-fragments-index="5"><a href="https://angular.io/api/core/DebugElement" target="api"><code>DebugElement</code></a>: Wrapper für DOM-Element(e) der View unter Test. Enthält <a href="https://angular.io/guide/testing#debugelement" target="api">Methoden</a> für Suche in und Manipulation der DOM</li>
								</ul>
							</li>
							<li>Nahtlose Integration in Jasmine-Framework</li>
						</ul>
					</section>
					<section>
						<h3>Test-Skelett</h3>
					<pre><code style="font-size:80%" data-trim data-noescape>&lt;!-- Imports --&gt;
describe('TestedComponent', () => {
	let component: TestedComponent;
	let fixture: ComponentFixture<TestedComponent>;
	beforeEach(async(() => { // Async-Wrapper
		TestBed.configureTestingModule({ // Konfiguration des Testmoduls
			declarations: [ TestedComponent ]
		})
		.compileComponents();
	}));
	beforeEach(() => {
		fixture = TestBed.createComponent(TestedComponent); // ComponentFixture
		component = fixture.componentInstance;
		fixture.detectChanges(); // Bemerkt Aktualisierungen der DOM
	});
	it('should create', () => {
		expect(component).toBeTruthy(); // Konnte Komponente erstellt werden?
	});
});</code></pre>
					</section>
				<section>
					<h3>Testen der DOM mit DebugElement</h3>
					<ul>
						<li  class="fragment" data-fragments-index="1"><code>debugElement</code>: Gibt Referenz vom Typ <a href="https://angular.io/api/core/DebugElement" target="api"><code>DebugElement</code></a> auf DOM-Element zurück.</li>
            <li class="fragment" data-fragments-index="2">Einige Methoden von <code>DebugElement</code>:
                <ul>
                    <li class="fragment" data-fragments-index="3"><code>query(&lt;pred&gt;)</code> / <code>queryAll(&lt;pred&gt;)</code>: Nimmt ein Prädikat entgegen und gibt das erste / alle passenden <code>DebugElement</code>(s) zurück. Prädikate werden mit statischen Methoden der Klasse <a href="https://angular.io/api/platform-browser/By" target="api"><code>By</code></a> gebildet</li>
                    <li class="fragment" data-fragments-index="4"><code>nativeElement</code>: Gibt von <code>DebugElement</code> referenziertes DOM-Element zurück</li>
                    <li class="fragment" data-fragments-index="5"><code>injector</code>: Gibt den <i>Injector</i> der Komponente zurück</li>
                    <li class="fragment" data-fragments-index="6"><code>triggerEventHandler</code>: <a href="https://www.w3schools.com/jsref/dom_obj_event.asp" target="api"><i>Event</i></a> für DOM-Element auslösen</li>
                </ul>
            </li>
					</ul>
				</section>
        <section>
        <h3>Testen einer Komponente mit einem Service</h3>
          <ul>
            <li class="fragment" data-fragment-index="1"></li>
            <li class="fragment" data-fragment-index="2"></li>
            <li class="fragment" data-fragment-index="3"></li>
            <li class="fragment" data-fragment-index="4"></li>
          </ul>
        </section>
				</section>
				<section>
					<h2>Integrationstests</h2>
					<p style="color:red">Coming soon!</p>
				</section>
				<section>
					<h2>E2E Tests</h2>
					<p style="color:red">Coming soon!</p>
				</section>
				<section>
					<h2>Test-Driven Development</h2>
					<p style="color:red">Coming soon!</p>
				</section>
			</div>

			<script src="lib/js/head.min.js"></script>
			<script src="js/reveal.js"></script>

			<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				slideNumber: false,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
			</script>
	</body>
</html>
